{"ast":null,"code":"import { keccak256 } from \"../crypto/index.js\";\nimport { concat, dataSlice, getBigInt, getBytes, encodeRlp, assertArgument } from \"../utils/index.js\";\nimport { getAddress } from \"./address.js\";\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n/**\r\n *  Returns the address that would result from a ``CREATE`` for %%tx%%.\r\n *\r\n *  This can be used to compute the address a contract will be\r\n *  deployed to by an EOA when sending a deployment transaction (i.e.\r\n *  when the ``to`` address is ``null``).\r\n *\r\n *  This can also be used to compute the address a contract will be\r\n *  deployed to by a contract, by using the contract's address as the\r\n *  ``to`` and the contract's nonce.\r\n *\r\n *  @example\r\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\r\n *    nonce = 5;\r\n *\r\n *    getCreateAddress({ from, nonce });\r\n *    //_result:\r\n */\nexport function getCreateAddress(tx) {\n  const from = getAddress(tx.from);\n  const nonce = getBigInt(tx.nonce, \"tx.nonce\");\n  let nonceHex = nonce.toString(16);\n  if (nonceHex === \"0\") {\n    nonceHex = \"0x\";\n  } else if (nonceHex.length % 2) {\n    nonceHex = \"0x0\" + nonceHex;\n  } else {\n    nonceHex = \"0x\" + nonceHex;\n  }\n  return getAddress(dataSlice(keccak256(encodeRlp([from, nonceHex])), 12));\n}\n/**\r\n *  Returns the address that would result from a ``CREATE2`` operation\r\n *  with the given %%from%%, %%salt%% and %%initCodeHash%%.\r\n *\r\n *  To compute the %%initCodeHash%% from a contract's init code, use\r\n *  the [[keccak256]] function.\r\n *\r\n *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].\r\n *\r\n *  @example\r\n *    // The address of the contract\r\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\r\n *\r\n *    // The salt\r\n *    salt = id(\"HelloWorld\")\r\n *\r\n *    // The hash of the initCode\r\n *    initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\r\n *    initCodeHash = keccak256(initCode)\r\n *\r\n *    getCreate2Address(from, salt, initCodeHash)\r\n *    //_result:\r\n */\nexport function getCreate2Address(_from, _salt, _initCodeHash) {\n  const from = getAddress(_from);\n  const salt = getBytes(_salt, \"salt\");\n  const initCodeHash = getBytes(_initCodeHash, \"initCodeHash\");\n  assertArgument(salt.length === 32, \"salt must be 32 bytes\", \"salt\", _salt);\n  assertArgument(initCodeHash.length === 32, \"initCodeHash must be 32 bytes\", \"initCodeHash\", _initCodeHash);\n  return getAddress(dataSlice(keccak256(concat([\"0xff\", from, salt, initCodeHash])), 12));\n}","map":{"version":3,"names":["keccak256","concat","dataSlice","getBigInt","getBytes","encodeRlp","assertArgument","getAddress","getCreateAddress","tx","from","nonce","nonceHex","toString","length","getCreate2Address","_from","_salt","_initCodeHash","salt","initCodeHash"],"sources":["C:\\Users\\patil\\OneDrive\\Desktop\\Hack4Good\\Supply-Chain\\supply-chain\\node_modules\\ethers\\src.ts\\address\\contract-address.ts"],"sourcesContent":["import { keccak256 } from \"../crypto/index.js\";\r\nimport {\r\n    concat, dataSlice, getBigInt, getBytes, encodeRlp, assertArgument\r\n} from \"../utils/index.js\";\r\n\r\nimport { getAddress } from \"./address.js\";\r\n\r\nimport type { BigNumberish, BytesLike } from \"../utils/index.js\";\r\n\r\n\r\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\r\n\r\n/**\r\n *  Returns the address that would result from a ``CREATE`` for %%tx%%.\r\n *\r\n *  This can be used to compute the address a contract will be\r\n *  deployed to by an EOA when sending a deployment transaction (i.e.\r\n *  when the ``to`` address is ``null``).\r\n *\r\n *  This can also be used to compute the address a contract will be\r\n *  deployed to by a contract, by using the contract's address as the\r\n *  ``to`` and the contract's nonce.\r\n *\r\n *  @example\r\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\r\n *    nonce = 5;\r\n *\r\n *    getCreateAddress({ from, nonce });\r\n *    //_result:\r\n */\r\nexport function getCreateAddress(tx: { from: string, nonce: BigNumberish }): string {\r\n    const from = getAddress(tx.from);\r\n    const nonce = getBigInt(tx.nonce, \"tx.nonce\");\r\n\r\n    let nonceHex = nonce.toString(16);\r\n    if (nonceHex === \"0\") {\r\n        nonceHex = \"0x\";\r\n    } else if (nonceHex.length % 2) {\r\n        nonceHex = \"0x0\" + nonceHex;\r\n    } else {\r\n        nonceHex = \"0x\" + nonceHex;\r\n    }\r\n\r\n    return getAddress(dataSlice(keccak256(encodeRlp([ from, nonceHex ])), 12));\r\n}\r\n\r\n/**\r\n *  Returns the address that would result from a ``CREATE2`` operation\r\n *  with the given %%from%%, %%salt%% and %%initCodeHash%%.\r\n *\r\n *  To compute the %%initCodeHash%% from a contract's init code, use\r\n *  the [[keccak256]] function.\r\n *\r\n *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].\r\n *\r\n *  @example\r\n *    // The address of the contract\r\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\r\n *\r\n *    // The salt\r\n *    salt = id(\"HelloWorld\")\r\n *\r\n *    // The hash of the initCode\r\n *    initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\r\n *    initCodeHash = keccak256(initCode)\r\n *\r\n *    getCreate2Address(from, salt, initCodeHash)\r\n *    //_result:\r\n */\r\nexport function getCreate2Address(_from: string, _salt: BytesLike, _initCodeHash: BytesLike): string {\r\n    const from = getAddress(_from);\r\n    const salt = getBytes(_salt, \"salt\");\r\n    const initCodeHash = getBytes(_initCodeHash, \"initCodeHash\");\r\n\r\n    assertArgument(salt.length === 32, \"salt must be 32 bytes\", \"salt\", _salt);\r\n\r\n    assertArgument(initCodeHash.length === 32, \"initCodeHash must be 32 bytes\", \"initCodeHash\", _initCodeHash);\r\n\r\n    return getAddress(dataSlice(keccak256(concat([ \"0xff\", from, salt, initCodeHash ])), 12))\r\n}\r\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,oBAAoB;AAC9C,SACIC,MAAM,EAAEC,SAAS,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,cAAc,QAC9D,mBAAmB;AAE1B,SAASC,UAAU,QAAQ,cAAc;AAKzC;AAEA;;;;;;;;;;;;;;;;;;AAkBA,OAAM,SAAUC,gBAAgBA,CAACC,EAAyC;EACtE,MAAMC,IAAI,GAAGH,UAAU,CAACE,EAAE,CAACC,IAAI,CAAC;EAChC,MAAMC,KAAK,GAAGR,SAAS,CAACM,EAAE,CAACE,KAAK,EAAE,UAAU,CAAC;EAE7C,IAAIC,QAAQ,GAAGD,KAAK,CAACE,QAAQ,CAAC,EAAE,CAAC;EACjC,IAAID,QAAQ,KAAK,GAAG,EAAE;IAClBA,QAAQ,GAAG,IAAI;GAClB,MAAM,IAAIA,QAAQ,CAACE,MAAM,GAAG,CAAC,EAAE;IAC5BF,QAAQ,GAAG,KAAK,GAAGA,QAAQ;GAC9B,MAAM;IACHA,QAAQ,GAAG,IAAI,GAAGA,QAAQ;;EAG9B,OAAOL,UAAU,CAACL,SAAS,CAACF,SAAS,CAACK,SAAS,CAAC,CAAEK,IAAI,EAAEE,QAAQ,CAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;AAC9E;AAEA;;;;;;;;;;;;;;;;;;;;;;;AAuBA,OAAM,SAAUG,iBAAiBA,CAACC,KAAa,EAAEC,KAAgB,EAAEC,aAAwB;EACvF,MAAMR,IAAI,GAAGH,UAAU,CAACS,KAAK,CAAC;EAC9B,MAAMG,IAAI,GAAGf,QAAQ,CAACa,KAAK,EAAE,MAAM,CAAC;EACpC,MAAMG,YAAY,GAAGhB,QAAQ,CAACc,aAAa,EAAE,cAAc,CAAC;EAE5DZ,cAAc,CAACa,IAAI,CAACL,MAAM,KAAK,EAAE,EAAE,uBAAuB,EAAE,MAAM,EAAEG,KAAK,CAAC;EAE1EX,cAAc,CAACc,YAAY,CAACN,MAAM,KAAK,EAAE,EAAE,+BAA+B,EAAE,cAAc,EAAEI,aAAa,CAAC;EAE1G,OAAOX,UAAU,CAACL,SAAS,CAACF,SAAS,CAACC,MAAM,CAAC,CAAE,MAAM,EAAES,IAAI,EAAES,IAAI,EAAEC,YAAY,CAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;AAC7F","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}