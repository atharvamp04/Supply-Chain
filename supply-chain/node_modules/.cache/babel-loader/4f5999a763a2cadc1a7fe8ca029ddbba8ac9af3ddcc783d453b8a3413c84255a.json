{"ast":null,"code":"/**\r\n *  [[link-etherscan]] provides a third-party service for connecting to\r\n *  various blockchains over a combination of JSON-RPC and custom API\r\n *  endpoints.\r\n *\r\n *  **Supported Networks**\r\n *\r\n *  - Ethereum Mainnet (``mainnet``)\r\n *  - Goerli Testnet (``goerli``)\r\n *  - Sepolia Testnet (``sepolia``)\r\n *  - Holesky Testnet (``holesky``)\r\n *  - Arbitrum (``arbitrum``)\r\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\r\n *  - Base (``base``)\r\n *  - Base Sepolia Testnet (``base-sepolia``)\r\n *  - BNB Smart Chain Mainnet (``bnb``)\r\n *  - BNB Smart Chain Testnet (``bnbt``)\r\n *  - Optimism (``optimism``)\r\n *  - Optimism Goerli Testnet (``optimism-goerli``)\r\n *  - Polygon (``matic``)\r\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\r\n *  - Polygon Amoy Testnet (``matic-amoy``)\r\n *\r\n *  @_subsection api/providers/thirdparty:Etherscan  [providers-etherscan]\r\n */\nimport { AbiCoder } from \"../abi/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { accessListify, Transaction } from \"../transaction/index.js\";\nimport { defineProperties, hexlify, toQuantity, FetchRequest, assert, assertArgument, isError,\n//    parseUnits,\ntoUtf8String } from \"../utils/index.js\";\nimport { AbstractProvider } from \"./abstract-provider.js\";\nimport { Network } from \"./network.js\";\nimport { NetworkPlugin } from \"./plugins-network.js\";\nimport { showThrottleMessage } from \"./community.js\";\nconst THROTTLE = 2000;\nfunction isPromise(value) {\n  return value && typeof value.then === \"function\";\n}\nconst EtherscanPluginId = \"org.ethers.plugins.provider.Etherscan\";\n/**\r\n *  A Network can include an **EtherscanPlugin** to provide\r\n *  a custom base URL.\r\n *\r\n *  @_docloc: api/providers/thirdparty:Etherscan\r\n */\nexport class EtherscanPlugin extends NetworkPlugin {\n  /**\r\n   *  The Etherscan API base URL.\r\n   */\n  baseUrl;\n  /**\r\n   *  Creates a new **EtherscanProvider** which will use\r\n   *  %%baseUrl%%.\r\n   */\n  constructor(baseUrl) {\n    super(EtherscanPluginId);\n    defineProperties(this, {\n      baseUrl\n    });\n  }\n  clone() {\n    return new EtherscanPlugin(this.baseUrl);\n  }\n}\nconst skipKeys = [\"enableCcipRead\"];\nlet nextId = 1;\n/**\r\n *  The **EtherscanBaseProvider** is the super-class of\r\n *  [[EtherscanProvider]], which should generally be used instead.\r\n *\r\n *  Since the **EtherscanProvider** includes additional code for\r\n *  [[Contract]] access, in //rare cases// that contracts are not\r\n *  used, this class can reduce code size.\r\n *\r\n *  @_docloc: api/providers/thirdparty:Etherscan\r\n */\nexport class EtherscanProvider extends AbstractProvider {\n  /**\r\n   *  The connected network.\r\n   */\n  network;\n  /**\r\n   *  The API key or null if using the community provided bandwidth.\r\n   */\n  apiKey;\n  #plugin;\n  /**\r\n   *  Creates a new **EtherscanBaseProvider**.\r\n   */\n  constructor(_network, _apiKey) {\n    const apiKey = _apiKey != null ? _apiKey : null;\n    super();\n    const network = Network.from(_network);\n    this.#plugin = network.getPlugin(EtherscanPluginId);\n    defineProperties(this, {\n      apiKey,\n      network\n    });\n    // Test that the network is supported by Etherscan\n    this.getBaseUrl();\n  }\n  /**\r\n   *  Returns the base URL.\r\n   *\r\n   *  If an [[EtherscanPlugin]] is configured on the\r\n   *  [[EtherscanBaseProvider_network]], returns the plugin's\r\n   *  baseUrl.\r\n   */\n  getBaseUrl() {\n    if (this.#plugin) {\n      return this.#plugin.baseUrl;\n    }\n    switch (this.network.name) {\n      case \"mainnet\":\n        return \"https:/\\/api.etherscan.io\";\n      case \"goerli\":\n        return \"https:/\\/api-goerli.etherscan.io\";\n      case \"sepolia\":\n        return \"https:/\\/api-sepolia.etherscan.io\";\n      case \"holesky\":\n        return \"https:/\\/api-holesky.etherscan.io\";\n      case \"arbitrum\":\n        return \"https:/\\/api.arbiscan.io\";\n      case \"arbitrum-goerli\":\n        return \"https:/\\/api-goerli.arbiscan.io\";\n      case \"base\":\n        return \"https:/\\/api.basescan.org\";\n      case \"base-sepolia\":\n        return \"https:/\\/api-sepolia.basescan.org\";\n      case \"bnb\":\n        return \"https:/\\/api.bscscan.com\";\n      case \"bnbt\":\n        return \"https:/\\/api-testnet.bscscan.com\";\n      case \"matic\":\n        return \"https:/\\/api.polygonscan.com\";\n      case \"matic-amoy\":\n        return \"https:/\\/api-amoy.polygonscan.com\";\n      case \"matic-mumbai\":\n        return \"https:/\\/api-testnet.polygonscan.com\";\n      case \"optimism\":\n        return \"https:/\\/api-optimistic.etherscan.io\";\n      case \"optimism-goerli\":\n        return \"https:/\\/api-goerli-optimistic.etherscan.io\";\n      default:\n    }\n    assertArgument(false, \"unsupported network\", \"network\", this.network);\n  }\n  /**\r\n   *  Returns the URL for the %%module%% and %%params%%.\r\n   */\n  getUrl(module, params) {\n    const query = Object.keys(params).reduce((accum, key) => {\n      const value = params[key];\n      if (value != null) {\n        accum += `&${key}=${value}`;\n      }\n      return accum;\n    }, \"\");\n    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : \"\";\n    return `${this.getBaseUrl()}/api?module=${module}${query}${apiKey}`;\n  }\n  /**\r\n   *  Returns the URL for using POST requests.\r\n   */\n  getPostUrl() {\n    return `${this.getBaseUrl()}/api`;\n  }\n  /**\r\n   *  Returns the parameters for using POST requests.\r\n   */\n  getPostData(module, params) {\n    params.module = module;\n    params.apikey = this.apiKey;\n    return params;\n  }\n  async detectNetwork() {\n    return this.network;\n  }\n  /**\r\n   *  Resolves to the result of calling %%module%% with %%params%%.\r\n   *\r\n   *  If %%post%%, the request is made as a POST request.\r\n   */\n  async fetch(module, params, post) {\n    const id = nextId++;\n    const url = post ? this.getPostUrl() : this.getUrl(module, params);\n    const payload = post ? this.getPostData(module, params) : null;\n    this.emit(\"debug\", {\n      action: \"sendRequest\",\n      id,\n      url,\n      payload: payload\n    });\n    const request = new FetchRequest(url);\n    request.setThrottleParams({\n      slotInterval: 1000\n    });\n    request.retryFunc = (req, resp, attempt) => {\n      if (this.isCommunityResource()) {\n        showThrottleMessage(\"Etherscan\");\n      }\n      return Promise.resolve(true);\n    };\n    request.processFunc = async (request, response) => {\n      const result = response.hasBody() ? JSON.parse(toUtf8String(response.body)) : {};\n      const throttle = (typeof result.result === \"string\" ? result.result : \"\").toLowerCase().indexOf(\"rate limit\") >= 0;\n      if (module === \"proxy\") {\n        // This JSON response indicates we are being throttled\n        if (result && result.status == 0 && result.message == \"NOTOK\" && throttle) {\n          this.emit(\"debug\", {\n            action: \"receiveError\",\n            id,\n            reason: \"proxy-NOTOK\",\n            error: result\n          });\n          response.throwThrottleError(result.result, THROTTLE);\n        }\n      } else {\n        if (throttle) {\n          this.emit(\"debug\", {\n            action: \"receiveError\",\n            id,\n            reason: \"null result\",\n            error: result.result\n          });\n          response.throwThrottleError(result.result, THROTTLE);\n        }\n      }\n      return response;\n    };\n    if (payload) {\n      request.setHeader(\"content-type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\n      request.body = Object.keys(payload).map(k => `${k}=${payload[k]}`).join(\"&\");\n    }\n    const response = await request.send();\n    try {\n      response.assertOk();\n    } catch (error) {\n      this.emit(\"debug\", {\n        action: \"receiveError\",\n        id,\n        error,\n        reason: \"assertOk\"\n      });\n      assert(false, \"response error\", \"SERVER_ERROR\", {\n        request,\n        response\n      });\n    }\n    if (!response.hasBody()) {\n      this.emit(\"debug\", {\n        action: \"receiveError\",\n        id,\n        error: \"missing body\",\n        reason: \"null body\"\n      });\n      assert(false, \"missing response\", \"SERVER_ERROR\", {\n        request,\n        response\n      });\n    }\n    const result = JSON.parse(toUtf8String(response.body));\n    if (module === \"proxy\") {\n      if (result.jsonrpc != \"2.0\") {\n        this.emit(\"debug\", {\n          action: \"receiveError\",\n          id,\n          result,\n          reason: \"invalid JSON-RPC\"\n        });\n        assert(false, \"invalid JSON-RPC response (missing jsonrpc='2.0')\", \"SERVER_ERROR\", {\n          request,\n          response,\n          info: {\n            result\n          }\n        });\n      }\n      if (result.error) {\n        this.emit(\"debug\", {\n          action: \"receiveError\",\n          id,\n          result,\n          reason: \"JSON-RPC error\"\n        });\n        assert(false, \"error response\", \"SERVER_ERROR\", {\n          request,\n          response,\n          info: {\n            result\n          }\n        });\n      }\n      this.emit(\"debug\", {\n        action: \"receiveRequest\",\n        id,\n        result\n      });\n      return result.result;\n    } else {\n      // getLogs, getHistory have weird success responses\n      if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        this.emit(\"debug\", {\n          action: \"receiveRequest\",\n          id,\n          result\n        });\n        return result.result;\n      }\n      if (result.status != 1 || typeof result.message === \"string\" && !result.message.match(/^OK/)) {\n        this.emit(\"debug\", {\n          action: \"receiveError\",\n          id,\n          result\n        });\n        assert(false, \"error response\", \"SERVER_ERROR\", {\n          request,\n          response,\n          info: {\n            result\n          }\n        });\n      }\n      this.emit(\"debug\", {\n        action: \"receiveRequest\",\n        id,\n        result\n      });\n      return result.result;\n    }\n  }\n  /**\r\n   *  Returns %%transaction%% normalized for the Etherscan API.\r\n   */\n  _getTransactionPostData(transaction) {\n    const result = {};\n    for (let key in transaction) {\n      if (skipKeys.indexOf(key) >= 0) {\n        continue;\n      }\n      if (transaction[key] == null) {\n        continue;\n      }\n      let value = transaction[key];\n      if (key === \"type\" && value === 0) {\n        continue;\n      }\n      if (key === \"blockTag\" && value === \"latest\") {\n        continue;\n      }\n      // Quantity-types require no leading zero, unless 0\n      if ({\n        type: true,\n        gasLimit: true,\n        gasPrice: true,\n        maxFeePerGs: true,\n        maxPriorityFeePerGas: true,\n        nonce: true,\n        value: true\n      }[key]) {\n        value = toQuantity(value);\n      } else if (key === \"accessList\") {\n        value = \"[\" + accessListify(value).map(set => {\n          return `{address:\"${set.address}\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`;\n        }).join(\",\") + \"]\";\n      } else if (key === \"blobVersionedHashes\") {\n        if (value.length === 0) {\n          continue;\n        }\n        // @TODO: update this once the API supports blobs\n        assert(false, \"Etherscan API does not support blobVersionedHashes\", \"UNSUPPORTED_OPERATION\", {\n          operation: \"_getTransactionPostData\",\n          info: {\n            transaction\n          }\n        });\n      } else {\n        value = hexlify(value);\n      }\n      result[key] = value;\n    }\n    return result;\n  }\n  /**\r\n   *  Throws the normalized Etherscan error.\r\n   */\n  _checkError(req, error, transaction) {\n    // Pull any message out if, possible\n    let message = \"\";\n    if (isError(error, \"SERVER_ERROR\")) {\n      // Check for an error emitted by a proxy call\n      try {\n        message = error.info.result.error.message;\n      } catch (e) {}\n      if (!message) {\n        try {\n          message = error.info.message;\n        } catch (e) {}\n      }\n    }\n    if (req.method === \"estimateGas\") {\n      if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {\n        assert(false, \"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n          transaction: req.transaction\n        });\n      }\n    }\n    if (req.method === \"call\" || req.method === \"estimateGas\") {\n      if (message.match(/execution reverted/i)) {\n        let data = \"\";\n        try {\n          data = error.info.result.error.data;\n        } catch (error) {}\n        const e = AbiCoder.getBuiltinCallException(req.method, req.transaction, data);\n        e.info = {\n          request: req,\n          error\n        };\n        throw e;\n      }\n    }\n    if (message) {\n      if (req.method === \"broadcastTransaction\") {\n        const transaction = Transaction.from(req.signedTransaction);\n        if (message.match(/replacement/i) && message.match(/underpriced/i)) {\n          assert(false, \"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\n            transaction\n          });\n        }\n        if (message.match(/insufficient funds/)) {\n          assert(false, \"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n            transaction\n          });\n        }\n        if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n          assert(false, \"nonce has already been used\", \"NONCE_EXPIRED\", {\n            transaction\n          });\n        }\n      }\n    }\n    // Something we could not process\n    throw error;\n  }\n  async _detectNetwork() {\n    return this.network;\n  }\n  async _perform(req) {\n    switch (req.method) {\n      case \"chainId\":\n        return this.network.chainId;\n      case \"getBlockNumber\":\n        return this.fetch(\"proxy\", {\n          action: \"eth_blockNumber\"\n        });\n      case \"getGasPrice\":\n        return this.fetch(\"proxy\", {\n          action: \"eth_gasPrice\"\n        });\n      case \"getPriorityFee\":\n        // This is temporary until Etherscan completes support\n        if (this.network.name === \"mainnet\") {\n          return \"1000000000\";\n        } else if (this.network.name === \"optimism\") {\n          return \"1000000\";\n        } else {\n          throw new Error(\"fallback onto the AbstractProvider default\");\n        }\n      /* Working with Etherscan to get this added:\r\n      try {\r\n          const test = await this.fetch(\"proxy\", {\r\n              action: \"eth_maxPriorityFeePerGas\"\r\n          });\r\n          console.log(test);\r\n          return test;\r\n      } catch (e) {\r\n          console.log(\"DEBUG\", e);\r\n          throw e;\r\n      }\r\n      */\n      /* This might be safe; but due to rounding neither myself\r\n         or Etherscan are necessarily comfortable with this. :)\r\n      try {\r\n          const result = await this.fetch(\"gastracker\", { action: \"gasoracle\" });\r\n          console.log(result);\r\n          const gasPrice = parseUnits(result.SafeGasPrice, \"gwei\");\r\n          const baseFee = parseUnits(result.suggestBaseFee, \"gwei\");\r\n          const priorityFee = gasPrice - baseFee;\r\n          if (priorityFee < 0) { throw new Error(\"negative priority fee; defer to abstract provider default\"); }\r\n          return priorityFee;\r\n      } catch (error) {\r\n          console.log(\"DEBUG\", error);\r\n          throw error;\r\n      }\r\n      */\n      case \"getBalance\":\n        // Returns base-10 result\n        return this.fetch(\"account\", {\n          action: \"balance\",\n          address: req.address,\n          tag: req.blockTag\n        });\n      case \"getTransactionCount\":\n        return this.fetch(\"proxy\", {\n          action: \"eth_getTransactionCount\",\n          address: req.address,\n          tag: req.blockTag\n        });\n      case \"getCode\":\n        return this.fetch(\"proxy\", {\n          action: \"eth_getCode\",\n          address: req.address,\n          tag: req.blockTag\n        });\n      case \"getStorage\":\n        return this.fetch(\"proxy\", {\n          action: \"eth_getStorageAt\",\n          address: req.address,\n          position: req.position,\n          tag: req.blockTag\n        });\n      case \"broadcastTransaction\":\n        return this.fetch(\"proxy\", {\n          action: \"eth_sendRawTransaction\",\n          hex: req.signedTransaction\n        }, true).catch(error => {\n          return this._checkError(req, error, req.signedTransaction);\n        });\n      case \"getBlock\":\n        if (\"blockTag\" in req) {\n          return this.fetch(\"proxy\", {\n            action: \"eth_getBlockByNumber\",\n            tag: req.blockTag,\n            boolean: req.includeTransactions ? \"true\" : \"false\"\n          });\n        }\n        assert(false, \"getBlock by blockHash not supported by Etherscan\", \"UNSUPPORTED_OPERATION\", {\n          operation: \"getBlock(blockHash)\"\n        });\n      case \"getTransaction\":\n        return this.fetch(\"proxy\", {\n          action: \"eth_getTransactionByHash\",\n          txhash: req.hash\n        });\n      case \"getTransactionReceipt\":\n        return this.fetch(\"proxy\", {\n          action: \"eth_getTransactionReceipt\",\n          txhash: req.hash\n        });\n      case \"call\":\n        {\n          if (req.blockTag !== \"latest\") {\n            throw new Error(\"EtherscanProvider does not support blockTag for call\");\n          }\n          const postData = this._getTransactionPostData(req.transaction);\n          postData.module = \"proxy\";\n          postData.action = \"eth_call\";\n          try {\n            return await this.fetch(\"proxy\", postData, true);\n          } catch (error) {\n            return this._checkError(req, error, req.transaction);\n          }\n        }\n      case \"estimateGas\":\n        {\n          const postData = this._getTransactionPostData(req.transaction);\n          postData.module = \"proxy\";\n          postData.action = \"eth_estimateGas\";\n          try {\n            return await this.fetch(\"proxy\", postData, true);\n          } catch (error) {\n            return this._checkError(req, error, req.transaction);\n          }\n        }\n      /*\r\n                  case \"getLogs\": {\r\n                      // Needs to complain if more than one address is passed in\r\n                      const args: Record<string, any> = { action: \"getLogs\" }\r\n      \r\n                      if (params.filter.fromBlock) {\r\n                          args.fromBlock = checkLogTag(params.filter.fromBlock);\r\n                      }\r\n      \r\n                      if (params.filter.toBlock) {\r\n                          args.toBlock = checkLogTag(params.filter.toBlock);\r\n                      }\r\n      \r\n                      if (params.filter.address) {\r\n                          args.address = params.filter.address;\r\n                      }\r\n      \r\n                      // @TODO: We can handle slightly more complicated logs using the logs API\r\n                      if (params.filter.topics && params.filter.topics.length > 0) {\r\n                          if (params.filter.topics.length > 1) {\r\n                              logger.throwError(\"unsupported topic count\", Logger.Errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\r\n                          }\r\n                          if (params.filter.topics.length === 1) {\r\n                              const topic0 = params.filter.topics[0];\r\n                              if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\r\n                                  logger.throwError(\"unsupported topic format\", Logger.Errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\r\n                              }\r\n                              args.topic0 = topic0;\r\n                          }\r\n                      }\r\n      \r\n                      const logs: Array<any> = await this.fetch(\"logs\", args);\r\n      \r\n                      // Cache txHash => blockHash\r\n                      let blocks: { [tag: string]: string } = {};\r\n      \r\n                      // Add any missing blockHash to the logs\r\n                      for (let i = 0; i < logs.length; i++) {\r\n                          const log = logs[i];\r\n                          if (log.blockHash != null) { continue; }\r\n                          if (blocks[log.blockNumber] == null) {\r\n                              const block = await this.getBlock(log.blockNumber);\r\n                              if (block) {\r\n                                  blocks[log.blockNumber] = block.hash;\r\n                              }\r\n                          }\r\n      \r\n                          log.blockHash = blocks[log.blockNumber];\r\n                      }\r\n      \r\n                      return logs;\r\n                  }\r\n      */\n      default:\n        break;\n    }\n    return super._perform(req);\n  }\n  async getNetwork() {\n    return this.network;\n  }\n  /**\r\n   *  Resolves to the current price of ether.\r\n   *\r\n   *  This returns ``0`` on any network other than ``mainnet``.\r\n   */\n  async getEtherPrice() {\n    if (this.network.name !== \"mainnet\") {\n      return 0.0;\n    }\n    return parseFloat((await this.fetch(\"stats\", {\n      action: \"ethprice\"\n    })).ethusd);\n  }\n  /**\r\n   *  Resolves to a [Contract]] for %%address%%, using the\r\n   *  Etherscan API to retreive the Contract ABI.\r\n   */\n  async getContract(_address) {\n    let address = this._getAddress(_address);\n    if (isPromise(address)) {\n      address = await address;\n    }\n    try {\n      const resp = await this.fetch(\"contract\", {\n        action: \"getabi\",\n        address\n      });\n      const abi = JSON.parse(resp);\n      return new Contract(address, abi, this);\n    } catch (error) {\n      return null;\n    }\n  }\n  isCommunityResource() {\n    return this.apiKey == null;\n  }\n}","map":{"version":3,"names":["AbiCoder","Contract","accessListify","Transaction","defineProperties","hexlify","toQuantity","FetchRequest","assert","assertArgument","isError","toUtf8String","AbstractProvider","Network","NetworkPlugin","showThrottleMessage","THROTTLE","isPromise","value","then","EtherscanPluginId","EtherscanPlugin","baseUrl","constructor","clone","skipKeys","nextId","EtherscanProvider","network","apiKey","plugin","_network","_apiKey","from","getPlugin","getBaseUrl","name","getUrl","module","params","query","Object","keys","reduce","accum","key","getPostUrl","getPostData","apikey","detectNetwork","fetch","post","id","url","payload","emit","action","request","setThrottleParams","slotInterval","retryFunc","req","resp","attempt","isCommunityResource","Promise","resolve","processFunc","response","result","hasBody","JSON","parse","body","throttle","toLowerCase","indexOf","status","message","reason","error","throwThrottleError","setHeader","map","k","join","send","assertOk","jsonrpc","info","match","_getTransactionPostData","transaction","type","gasLimit","gasPrice","maxFeePerGs","maxPriorityFeePerGas","nonce","set","address","storageKeys","length","operation","_checkError","e","method","data","getBuiltinCallException","signedTransaction","_detectNetwork","_perform","chainId","Error","tag","blockTag","position","hex","catch","boolean","includeTransactions","txhash","hash","postData","getNetwork","getEtherPrice","parseFloat","ethusd","getContract","_address","_getAddress","abi"],"sources":["C:\\Users\\patil\\OneDrive\\Desktop\\Hack4Good\\Supply-Chain\\supply-chain\\node_modules\\ethers\\src.ts\\providers\\provider-etherscan.ts"],"sourcesContent":["/**\r\n *  [[link-etherscan]] provides a third-party service for connecting to\r\n *  various blockchains over a combination of JSON-RPC and custom API\r\n *  endpoints.\r\n *\r\n *  **Supported Networks**\r\n *\r\n *  - Ethereum Mainnet (``mainnet``)\r\n *  - Goerli Testnet (``goerli``)\r\n *  - Sepolia Testnet (``sepolia``)\r\n *  - Holesky Testnet (``holesky``)\r\n *  - Arbitrum (``arbitrum``)\r\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\r\n *  - Base (``base``)\r\n *  - Base Sepolia Testnet (``base-sepolia``)\r\n *  - BNB Smart Chain Mainnet (``bnb``)\r\n *  - BNB Smart Chain Testnet (``bnbt``)\r\n *  - Optimism (``optimism``)\r\n *  - Optimism Goerli Testnet (``optimism-goerli``)\r\n *  - Polygon (``matic``)\r\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\r\n *  - Polygon Amoy Testnet (``matic-amoy``)\r\n *\r\n *  @_subsection api/providers/thirdparty:Etherscan  [providers-etherscan]\r\n */\r\n\r\nimport { AbiCoder } from \"../abi/index.js\";\r\nimport { Contract } from \"../contract/index.js\";\r\nimport { accessListify, Transaction } from \"../transaction/index.js\";\r\nimport {\r\n    defineProperties,\r\n    hexlify, toQuantity,\r\n    FetchRequest,\r\n    assert, assertArgument, isError,\r\n//    parseUnits,\r\n    toUtf8String\r\n } from \"../utils/index.js\";\r\n\r\nimport { AbstractProvider } from \"./abstract-provider.js\";\r\nimport { Network } from \"./network.js\";\r\nimport { NetworkPlugin } from \"./plugins-network.js\";\r\nimport { showThrottleMessage } from \"./community.js\";\r\n\r\nimport { PerformActionRequest } from \"./abstract-provider.js\";\r\nimport type { Networkish } from \"./network.js\";\r\n//import type { } from \"./pagination\";\r\nimport type { TransactionRequest } from \"./provider.js\";\r\n\r\nconst THROTTLE = 2000;\r\n\r\nfunction isPromise<T = any>(value: any): value is Promise<T> {\r\n    return (value && typeof(value.then) === \"function\");\r\n}\r\n\r\n\r\n/**\r\n *  When subscribing to the ``\"debug\"`` event on an Etherscan-based\r\n *  provider, the events receive a **DebugEventEtherscanProvider**\r\n *  payload.\r\n *\r\n *  @_docloc: api/providers/thirdparty:Etherscan\r\n */\r\nexport type DebugEventEtherscanProvider = {\r\n    action: \"sendRequest\",\r\n    id: number,\r\n    url: string,\r\n    payload: Record<string, any>\r\n} | {\r\n    action: \"receiveRequest\",\r\n    id: number,\r\n    result: any\r\n} | {\r\n    action: \"receiveError\",\r\n    id: number,\r\n    error: any\r\n};\r\n\r\nconst EtherscanPluginId = \"org.ethers.plugins.provider.Etherscan\";\r\n\r\n/**\r\n *  A Network can include an **EtherscanPlugin** to provide\r\n *  a custom base URL.\r\n *\r\n *  @_docloc: api/providers/thirdparty:Etherscan\r\n */\r\nexport class EtherscanPlugin extends NetworkPlugin {\r\n    /**\r\n     *  The Etherscan API base URL.\r\n     */\r\n    readonly baseUrl!: string;\r\n\r\n    /**\r\n     *  Creates a new **EtherscanProvider** which will use\r\n     *  %%baseUrl%%.\r\n     */\r\n    constructor(baseUrl: string) {\r\n        super(EtherscanPluginId);\r\n        defineProperties<EtherscanPlugin>(this, { baseUrl });\r\n    }\r\n\r\n    clone(): EtherscanPlugin {\r\n        return new EtherscanPlugin(this.baseUrl);\r\n    }\r\n}\r\n\r\nconst skipKeys = [ \"enableCcipRead\" ];\r\n\r\nlet nextId = 1;\r\n\r\n/**\r\n *  The **EtherscanBaseProvider** is the super-class of\r\n *  [[EtherscanProvider]], which should generally be used instead.\r\n *\r\n *  Since the **EtherscanProvider** includes additional code for\r\n *  [[Contract]] access, in //rare cases// that contracts are not\r\n *  used, this class can reduce code size.\r\n *\r\n *  @_docloc: api/providers/thirdparty:Etherscan\r\n */\r\nexport class EtherscanProvider extends AbstractProvider {\r\n\r\n    /**\r\n     *  The connected network.\r\n     */\r\n    readonly network!: Network;\r\n\r\n    /**\r\n     *  The API key or null if using the community provided bandwidth.\r\n     */\r\n    readonly apiKey!: null | string;\r\n\r\n    readonly #plugin: null | EtherscanPlugin;\r\n\r\n    /**\r\n     *  Creates a new **EtherscanBaseProvider**.\r\n     */\r\n    constructor(_network?: Networkish, _apiKey?: string) {\r\n        const apiKey = (_apiKey != null) ? _apiKey: null;\r\n\r\n        super();\r\n\r\n        const network = Network.from(_network);\r\n\r\n        this.#plugin = network.getPlugin<EtherscanPlugin>(EtherscanPluginId);\r\n\r\n        defineProperties<EtherscanProvider>(this, { apiKey, network });\r\n\r\n        // Test that the network is supported by Etherscan\r\n        this.getBaseUrl();\r\n    }\r\n\r\n    /**\r\n     *  Returns the base URL.\r\n     *\r\n     *  If an [[EtherscanPlugin]] is configured on the\r\n     *  [[EtherscanBaseProvider_network]], returns the plugin's\r\n     *  baseUrl.\r\n     */\r\n    getBaseUrl(): string {\r\n        if (this.#plugin) { return this.#plugin.baseUrl; }\r\n\r\n        switch(this.network.name) {\r\n            case \"mainnet\":\r\n                return \"https:/\\/api.etherscan.io\";\r\n            case \"goerli\":\r\n                return \"https:/\\/api-goerli.etherscan.io\";\r\n            case \"sepolia\":\r\n                return \"https:/\\/api-sepolia.etherscan.io\";\r\n            case \"holesky\":\r\n                return \"https:/\\/api-holesky.etherscan.io\";\r\n\r\n            case \"arbitrum\":\r\n                return \"https:/\\/api.arbiscan.io\";\r\n            case \"arbitrum-goerli\":\r\n                return \"https:/\\/api-goerli.arbiscan.io\";\r\n           case \"base\":\r\n                return \"https:/\\/api.basescan.org\";\r\n            case \"base-sepolia\":\r\n                return \"https:/\\/api-sepolia.basescan.org\";\r\n            case \"bnb\":\r\n                return \"https:/\\/api.bscscan.com\";\r\n            case \"bnbt\":\r\n                return \"https:/\\/api-testnet.bscscan.com\";\r\n            case \"matic\":\r\n                return \"https:/\\/api.polygonscan.com\";\r\n            case \"matic-amoy\":\r\n                return \"https:/\\/api-amoy.polygonscan.com\";\r\n            case \"matic-mumbai\":\r\n                return \"https:/\\/api-testnet.polygonscan.com\";\r\n            case \"optimism\":\r\n                return \"https:/\\/api-optimistic.etherscan.io\";\r\n            case \"optimism-goerli\":\r\n                return \"https:/\\/api-goerli-optimistic.etherscan.io\";\r\n\r\n            default:\r\n        }\r\n\r\n        assertArgument(false, \"unsupported network\", \"network\", this.network);\r\n    }\r\n\r\n    /**\r\n     *  Returns the URL for the %%module%% and %%params%%.\r\n     */\r\n    getUrl(module: string, params: Record<string, string>): string {\r\n        const query = Object.keys(params).reduce((accum, key) => {\r\n            const value = params[key];\r\n            if (value != null) {\r\n                accum += `&${ key }=${ value }`\r\n            }\r\n            return accum\r\n        }, \"\");\r\n        const apiKey = ((this.apiKey) ? `&apikey=${ this.apiKey }`: \"\");\r\n        return `${ this.getBaseUrl() }/api?module=${ module }${ query }${ apiKey }`;\r\n    }\r\n\r\n    /**\r\n     *  Returns the URL for using POST requests.\r\n     */\r\n    getPostUrl(): string {\r\n        return `${ this.getBaseUrl() }/api`;\r\n    }\r\n\r\n    /**\r\n     *  Returns the parameters for using POST requests.\r\n     */\r\n    getPostData(module: string, params: Record<string, any>): Record<string, any> {\r\n        params.module = module;\r\n        params.apikey = this.apiKey;\r\n        return params;\r\n    }\r\n\r\n    async detectNetwork(): Promise<Network> {\r\n        return this.network;\r\n    }\r\n\r\n    /**\r\n     *  Resolves to the result of calling %%module%% with %%params%%.\r\n     *\r\n     *  If %%post%%, the request is made as a POST request.\r\n     */\r\n    async fetch(module: string, params: Record<string, any>, post?: boolean): Promise<any> {\r\n        const id = nextId++;\r\n\r\n        const url = (post ? this.getPostUrl(): this.getUrl(module, params));\r\n        const payload = (post ? this.getPostData(module, params): null);\r\n\r\n        this.emit(\"debug\", { action: \"sendRequest\", id, url, payload: payload });\r\n\r\n        const request = new FetchRequest(url);\r\n        request.setThrottleParams({ slotInterval: 1000 });\r\n        request.retryFunc = (req, resp, attempt: number) => {\r\n            if (this.isCommunityResource()) {\r\n                showThrottleMessage(\"Etherscan\");\r\n            }\r\n            return Promise.resolve(true);\r\n        };\r\n        request.processFunc = async (request, response) => {\r\n            const result = response.hasBody() ? JSON.parse(toUtf8String(response.body)): { };\r\n            const throttle = ((typeof(result.result) === \"string\") ? result.result: \"\").toLowerCase().indexOf(\"rate limit\") >= 0;\r\n            if (module === \"proxy\") {\r\n                // This JSON response indicates we are being throttled\r\n                if (result && result.status == 0 && result.message == \"NOTOK\" && throttle) {\r\n                    this.emit(\"debug\", { action: \"receiveError\", id, reason: \"proxy-NOTOK\", error: result });\r\n                    response.throwThrottleError(result.result, THROTTLE);\r\n                }\r\n            } else {\r\n                if (throttle) {\r\n                    this.emit(\"debug\", { action: \"receiveError\", id, reason: \"null result\", error: result.result });\r\n                    response.throwThrottleError(result.result, THROTTLE);\r\n                }\r\n            }\r\n            return response;\r\n        };\r\n\r\n        if (payload) {\r\n            request.setHeader(\"content-type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\r\n            request.body = Object.keys(payload).map((k) => `${ k }=${ payload[k] }`).join(\"&\");\r\n        }\r\n\r\n        const response = await request.send();\r\n        try {\r\n            response.assertOk();\r\n        } catch (error) {\r\n            this.emit(\"debug\", { action: \"receiveError\", id, error, reason: \"assertOk\" });\r\n            assert(false, \"response error\", \"SERVER_ERROR\", { request, response });\r\n        }\r\n\r\n        if (!response.hasBody()) {\r\n            this.emit(\"debug\", { action: \"receiveError\", id, error: \"missing body\", reason: \"null body\" });\r\n            assert(false, \"missing response\", \"SERVER_ERROR\", { request, response });\r\n        }\r\n\r\n        const result = JSON.parse(toUtf8String(response.body));\r\n        if (module === \"proxy\") {\r\n            if (result.jsonrpc != \"2.0\") {\r\n                this.emit(\"debug\", { action: \"receiveError\", id, result, reason: \"invalid JSON-RPC\" });\r\n                assert(false, \"invalid JSON-RPC response (missing jsonrpc='2.0')\", \"SERVER_ERROR\", { request, response, info: { result } });\r\n            }\r\n\r\n            if (result.error) {\r\n                this.emit(\"debug\", { action: \"receiveError\", id, result, reason: \"JSON-RPC error\" });\r\n                assert(false, \"error response\", \"SERVER_ERROR\", { request, response, info: { result } });\r\n            }\r\n\r\n            this.emit(\"debug\", { action: \"receiveRequest\", id, result });\r\n\r\n            return result.result;\r\n\r\n        } else {\r\n            // getLogs, getHistory have weird success responses\r\n            if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\r\n                this.emit(\"debug\", { action: \"receiveRequest\", id, result });\r\n                return result.result;\r\n            }\r\n\r\n            if (result.status != 1 || (typeof(result.message) === \"string\" && !result.message.match(/^OK/))) {\r\n                this.emit(\"debug\", { action: \"receiveError\", id, result });\r\n                assert(false, \"error response\", \"SERVER_ERROR\", { request, response, info: { result } });\r\n            }\r\n\r\n            this.emit(\"debug\", { action: \"receiveRequest\", id, result });\r\n\r\n            return result.result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Returns %%transaction%% normalized for the Etherscan API.\r\n     */\r\n    _getTransactionPostData(transaction: TransactionRequest): Record<string, string> {\r\n        const result: Record<string, string> = { };\r\n        for (let key in transaction) {\r\n            if (skipKeys.indexOf(key) >= 0) { continue; }\r\n\r\n            if ((<any>transaction)[key] == null) { continue; }\r\n            let value = (<any>transaction)[key];\r\n            if (key === \"type\" && value === 0) { continue; }\r\n            if (key === \"blockTag\" && value === \"latest\") { continue; }\r\n\r\n            // Quantity-types require no leading zero, unless 0\r\n            if ((<any>{ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true })[key]) {\r\n                value = toQuantity(value);\r\n\r\n            } else if (key === \"accessList\") {\r\n                value = \"[\" + accessListify(value).map((set) => {\r\n                    return `{address:\"${ set.address }\",storageKeys:[\"${ set.storageKeys.join('\",\"') }\"]}`;\r\n                }).join(\",\") + \"]\";\r\n\r\n            } else if (key === \"blobVersionedHashes\") {\r\n                if (value.length === 0) { continue; }\r\n\r\n                // @TODO: update this once the API supports blobs\r\n                assert(false, \"Etherscan API does not support blobVersionedHashes\", \"UNSUPPORTED_OPERATION\", {\r\n                    operation: \"_getTransactionPostData\",\r\n                    info: { transaction }\r\n                });\r\n\r\n            } else {\r\n                value = hexlify(value);\r\n            }\r\n            result[key] = value;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *  Throws the normalized Etherscan error.\r\n     */\r\n    _checkError(req: PerformActionRequest, error: Error, transaction: any): never {\r\n\r\n        // Pull any message out if, possible\r\n        let message = \"\";\r\n        if (isError(error, \"SERVER_ERROR\")) {\r\n            // Check for an error emitted by a proxy call\r\n            try {\r\n                message = (<any>error).info.result.error.message;\r\n            } catch (e) { }\r\n\r\n            if (!message) {\r\n                try {\r\n                    message = (<any>error).info.message;\r\n                } catch (e) { }\r\n            }\r\n        }\r\n\r\n        if (req.method === \"estimateGas\") {\r\n            if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {\r\n                assert(false, \"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\r\n                    transaction: req.transaction\r\n                });\r\n            }\r\n        }\r\n\r\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\r\n            if (message.match(/execution reverted/i)) {\r\n                let data = \"\";\r\n                try {\r\n                    data = (<any>error).info.result.error.data;\r\n                } catch (error) { }\r\n\r\n                const e = AbiCoder.getBuiltinCallException(req.method, <any>req.transaction, data);\r\n                e.info = { request: req, error }\r\n                throw e;\r\n            }\r\n        }\r\n\r\n        if (message) {\r\n            if (req.method === \"broadcastTransaction\") {\r\n                const transaction = Transaction.from(req.signedTransaction);\r\n                if (message.match(/replacement/i) && message.match(/underpriced/i)) {\r\n                    assert(false, \"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\r\n                        transaction\r\n                    });\r\n                }\r\n\r\n                if (message.match(/insufficient funds/)) {\r\n                    assert(false, \"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\r\n                       transaction\r\n                    });\r\n                }\r\n\r\n                if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\r\n                    assert(false, \"nonce has already been used\", \"NONCE_EXPIRED\", {\r\n                       transaction\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        // Something we could not process\r\n        throw error;\r\n    }\r\n\r\n    async _detectNetwork(): Promise<Network> {\r\n        return this.network;\r\n    }\r\n\r\n    async _perform(req: PerformActionRequest): Promise<any> {\r\n        switch (req.method) {\r\n            case \"chainId\":\r\n                return this.network.chainId;\r\n\r\n            case \"getBlockNumber\":\r\n                return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\r\n\r\n            case \"getGasPrice\":\r\n                return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\r\n\r\n            case \"getPriorityFee\":\r\n                // This is temporary until Etherscan completes support\r\n                if (this.network.name === \"mainnet\") {\r\n                    return \"1000000000\";\r\n                } else if (this.network.name === \"optimism\") {\r\n                    return \"1000000\";\r\n                } else {\r\n                    throw new Error(\"fallback onto the AbstractProvider default\");\r\n                }\r\n                /* Working with Etherscan to get this added:\r\n                try {\r\n                    const test = await this.fetch(\"proxy\", {\r\n                        action: \"eth_maxPriorityFeePerGas\"\r\n                    });\r\n                    console.log(test);\r\n                    return test;\r\n                } catch (e) {\r\n                    console.log(\"DEBUG\", e);\r\n                    throw e;\r\n                }\r\n                */\r\n                /* This might be safe; but due to rounding neither myself\r\n                   or Etherscan are necessarily comfortable with this. :)\r\n                try {\r\n                    const result = await this.fetch(\"gastracker\", { action: \"gasoracle\" });\r\n                    console.log(result);\r\n                    const gasPrice = parseUnits(result.SafeGasPrice, \"gwei\");\r\n                    const baseFee = parseUnits(result.suggestBaseFee, \"gwei\");\r\n                    const priorityFee = gasPrice - baseFee;\r\n                    if (priorityFee < 0) { throw new Error(\"negative priority fee; defer to abstract provider default\"); }\r\n                    return priorityFee;\r\n                } catch (error) {\r\n                    console.log(\"DEBUG\", error);\r\n                    throw error;\r\n                }\r\n                */\r\n\r\n            case \"getBalance\":\r\n                // Returns base-10 result\r\n                return this.fetch(\"account\", {\r\n                    action: \"balance\",\r\n                    address: req.address,\r\n                    tag: req.blockTag\r\n                });\r\n\r\n           case \"getTransactionCount\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_getTransactionCount\",\r\n                    address: req.address,\r\n                    tag: req.blockTag\r\n                });\r\n\r\n            case \"getCode\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_getCode\",\r\n                    address: req.address,\r\n                    tag: req.blockTag\r\n                });\r\n\r\n            case \"getStorage\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_getStorageAt\",\r\n                    address: req.address,\r\n                    position: req.position,\r\n                    tag: req.blockTag\r\n                });\r\n\r\n            case \"broadcastTransaction\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_sendRawTransaction\",\r\n                    hex: req.signedTransaction\r\n                }, true).catch((error) => {\r\n                    return this._checkError(req, <Error>error, req.signedTransaction);\r\n                });\r\n\r\n            case \"getBlock\":\r\n                if (\"blockTag\" in req) {\r\n                    return this.fetch(\"proxy\", {\r\n                        action: \"eth_getBlockByNumber\",\r\n                        tag: req.blockTag,\r\n                        boolean: (req.includeTransactions ? \"true\": \"false\")\r\n                    });\r\n                }\r\n\r\n                assert(false, \"getBlock by blockHash not supported by Etherscan\", \"UNSUPPORTED_OPERATION\", {\r\n                    operation: \"getBlock(blockHash)\"\r\n                });\r\n\r\n            case \"getTransaction\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_getTransactionByHash\",\r\n                    txhash: req.hash\r\n                });\r\n\r\n            case \"getTransactionReceipt\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_getTransactionReceipt\",\r\n                    txhash: req.hash\r\n                });\r\n\r\n            case \"call\": {\r\n                if (req.blockTag !== \"latest\") {\r\n                    throw new Error(\"EtherscanProvider does not support blockTag for call\");\r\n                }\r\n\r\n                const postData = this._getTransactionPostData(req.transaction);\r\n                postData.module = \"proxy\";\r\n                postData.action = \"eth_call\";\r\n\r\n                try {\r\n                    return await this.fetch(\"proxy\", postData, true);\r\n                } catch (error) {\r\n                    return this._checkError(req, <Error>error, req.transaction);\r\n                }\r\n            }\r\n\r\n            case \"estimateGas\": {\r\n                const postData = this._getTransactionPostData(req.transaction);\r\n                postData.module = \"proxy\";\r\n                postData.action = \"eth_estimateGas\";\r\n\r\n                try {\r\n                    return await this.fetch(\"proxy\", postData, true);\r\n                } catch (error) {\r\n                    return this._checkError(req, <Error>error, req.transaction);\r\n                }\r\n            }\r\n/*\r\n            case \"getLogs\": {\r\n                // Needs to complain if more than one address is passed in\r\n                const args: Record<string, any> = { action: \"getLogs\" }\r\n\r\n                if (params.filter.fromBlock) {\r\n                    args.fromBlock = checkLogTag(params.filter.fromBlock);\r\n                }\r\n\r\n                if (params.filter.toBlock) {\r\n                    args.toBlock = checkLogTag(params.filter.toBlock);\r\n                }\r\n\r\n                if (params.filter.address) {\r\n                    args.address = params.filter.address;\r\n                }\r\n\r\n                // @TODO: We can handle slightly more complicated logs using the logs API\r\n                if (params.filter.topics && params.filter.topics.length > 0) {\r\n                    if (params.filter.topics.length > 1) {\r\n                        logger.throwError(\"unsupported topic count\", Logger.Errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\r\n                    }\r\n                    if (params.filter.topics.length === 1) {\r\n                        const topic0 = params.filter.topics[0];\r\n                        if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\r\n                            logger.throwError(\"unsupported topic format\", Logger.Errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\r\n                        }\r\n                        args.topic0 = topic0;\r\n                    }\r\n                }\r\n\r\n                const logs: Array<any> = await this.fetch(\"logs\", args);\r\n\r\n                // Cache txHash => blockHash\r\n                let blocks: { [tag: string]: string } = {};\r\n\r\n                // Add any missing blockHash to the logs\r\n                for (let i = 0; i < logs.length; i++) {\r\n                    const log = logs[i];\r\n                    if (log.blockHash != null) { continue; }\r\n                    if (blocks[log.blockNumber] == null) {\r\n                        const block = await this.getBlock(log.blockNumber);\r\n                        if (block) {\r\n                            blocks[log.blockNumber] = block.hash;\r\n                        }\r\n                    }\r\n\r\n                    log.blockHash = blocks[log.blockNumber];\r\n                }\r\n\r\n                return logs;\r\n            }\r\n*/\r\n            default:\r\n                break;\r\n        }\r\n\r\n        return super._perform(req);\r\n    }\r\n\r\n    async getNetwork(): Promise<Network> {\r\n        return this.network;\r\n    }\r\n\r\n    /**\r\n     *  Resolves to the current price of ether.\r\n     *\r\n     *  This returns ``0`` on any network other than ``mainnet``.\r\n     */\r\n    async getEtherPrice(): Promise<number> {\r\n        if (this.network.name !== \"mainnet\") { return 0.0; }\r\n        return parseFloat((await this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\r\n    }\r\n\r\n    /**\r\n     *  Resolves to a [Contract]] for %%address%%, using the\r\n     *  Etherscan API to retreive the Contract ABI.\r\n     */\r\n    async getContract(_address: string): Promise<null | Contract> {\r\n        let address = this._getAddress(_address);\r\n        if (isPromise(address)) { address = await address; }\r\n\r\n        try {\r\n            const resp = await this.fetch(\"contract\", {\r\n            action: \"getabi\", address });\r\n            const abi = JSON.parse(resp);\r\n            return new Contract(address, abi, this);\r\n        } catch (error) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    isCommunityResource(): boolean {\r\n        return (this.apiKey == null);\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}