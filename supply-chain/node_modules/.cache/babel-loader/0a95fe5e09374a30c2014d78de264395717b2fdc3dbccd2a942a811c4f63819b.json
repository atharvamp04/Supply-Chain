{"ast":null,"code":"import { assert, assertArgument } from \"../utils/index.js\";\nimport { getAddress } from \"./address.js\";\n/**\r\n *  Returns true if %%value%% is an object which implements the\r\n *  [[Addressable]] interface.\r\n *\r\n *  @example:\r\n *    // Wallets and AbstractSigner sub-classes\r\n *    isAddressable(Wallet.createRandom())\r\n *    //_result:\r\n *\r\n *    // Contracts\r\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\r\n *    isAddressable(contract)\r\n *    //_result:\r\n */\nexport function isAddressable(value) {\n  return value && typeof value.getAddress === \"function\";\n}\n/**\r\n *  Returns true if %%value%% is a valid address.\r\n *\r\n *  @example:\r\n *    // Valid address\r\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\r\n *    //_result:\r\n *\r\n *    // Valid ICAP address\r\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\r\n *    //_result:\r\n *\r\n *    // Invalid checksum\r\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\r\n *    //_result:\r\n *\r\n *    // Invalid ICAP checksum\r\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\r\n *    //_result:\r\n *\r\n *    // Not an address (an ENS name requires a provided and an\r\n *    // asynchronous API to access)\r\n *    isAddress(\"ricmoo.eth\")\r\n *    //_result:\r\n */\nexport function isAddress(value) {\n  try {\n    getAddress(value);\n    return true;\n  } catch (error) {}\n  return false;\n}\nasync function checkAddress(target, promise) {\n  const result = await promise;\n  if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n    assert(typeof target !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", {\n      value: target\n    });\n    assertArgument(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n  }\n  return getAddress(result);\n}\n/**\r\n *  Resolves to an address for the %%target%%, which may be any\r\n *  supported address type, an [[Addressable]] or a Promise which\r\n *  resolves to an address.\r\n *\r\n *  If an ENS name is provided, but that name has not been correctly\r\n *  configured a [[UnconfiguredNameError]] is thrown.\r\n *\r\n *  @example:\r\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\r\n *\r\n *    // Addresses are return synchronously\r\n *    resolveAddress(addr, provider)\r\n *    //_result:\r\n *\r\n *    // Address promises are resolved asynchronously\r\n *    resolveAddress(Promise.resolve(addr))\r\n *    //_result:\r\n *\r\n *    // ENS names are resolved asynchronously\r\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\r\n *    //_result:\r\n *\r\n *    // Addressable objects are resolved asynchronously\r\n *    contract = new Contract(addr, [ ])\r\n *    resolveAddress(contract, provider)\r\n *    //_result:\r\n *\r\n *    // Unconfigured ENS names reject\r\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\r\n *    //_error:\r\n *\r\n *    // ENS names require a NameResolver object passed in\r\n *    // (notice the provider was omitted)\r\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\r\n *    //_error:\r\n */\nexport function resolveAddress(target, resolver) {\n  if (typeof target === \"string\") {\n    if (target.match(/^0x[0-9a-f]{40}$/i)) {\n      return getAddress(target);\n    }\n    assert(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"resolveName\"\n    });\n    return checkAddress(target, resolver.resolveName(target));\n  } else if (isAddressable(target)) {\n    return checkAddress(target, target.getAddress());\n  } else if (target && typeof target.then === \"function\") {\n    return checkAddress(target, target);\n  }\n  assertArgument(false, \"unsupported addressable value\", \"target\", target);\n}","map":{"version":3,"names":["assert","assertArgument","getAddress","isAddressable","value","isAddress","error","checkAddress","target","promise","result","resolveAddress","resolver","match","operation","resolveName","then"],"sources":["C:\\Users\\patil\\OneDrive\\Desktop\\Hack4Good\\Supply-Chain\\supply-chain\\node_modules\\ethers\\src.ts\\address\\checks.ts"],"sourcesContent":["import { assert, assertArgument } from \"../utils/index.js\";\r\n\r\nimport { getAddress } from \"./address.js\";\r\n\r\nimport type { Addressable, AddressLike, NameResolver } from \"./index.js\";\r\n\r\n\r\n/**\r\n *  Returns true if %%value%% is an object which implements the\r\n *  [[Addressable]] interface.\r\n *\r\n *  @example:\r\n *    // Wallets and AbstractSigner sub-classes\r\n *    isAddressable(Wallet.createRandom())\r\n *    //_result:\r\n *\r\n *    // Contracts\r\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\r\n *    isAddressable(contract)\r\n *    //_result:\r\n */\r\nexport function isAddressable(value: any): value is Addressable {\r\n    return (value && typeof(value.getAddress) === \"function\");\r\n}\r\n\r\n/**\r\n *  Returns true if %%value%% is a valid address.\r\n *\r\n *  @example:\r\n *    // Valid address\r\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\r\n *    //_result:\r\n *\r\n *    // Valid ICAP address\r\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\r\n *    //_result:\r\n *\r\n *    // Invalid checksum\r\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\r\n *    //_result:\r\n *\r\n *    // Invalid ICAP checksum\r\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\r\n *    //_result:\r\n *\r\n *    // Not an address (an ENS name requires a provided and an\r\n *    // asynchronous API to access)\r\n *    isAddress(\"ricmoo.eth\")\r\n *    //_result:\r\n */\r\nexport function isAddress(value: any): value is string {\r\n    try {\r\n        getAddress(value);\r\n        return true;\r\n    } catch (error) { }\r\n    return false;\r\n}\r\n\r\nasync function checkAddress(target: any, promise: Promise<null | string>): Promise<string> {\r\n    const result = await promise;\r\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\r\n        assert(typeof(target) !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", { value: target });\r\n        assertArgument(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\r\n    }\r\n    return getAddress(result);\r\n}\r\n\r\n/**\r\n *  Resolves to an address for the %%target%%, which may be any\r\n *  supported address type, an [[Addressable]] or a Promise which\r\n *  resolves to an address.\r\n *\r\n *  If an ENS name is provided, but that name has not been correctly\r\n *  configured a [[UnconfiguredNameError]] is thrown.\r\n *\r\n *  @example:\r\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\r\n *\r\n *    // Addresses are return synchronously\r\n *    resolveAddress(addr, provider)\r\n *    //_result:\r\n *\r\n *    // Address promises are resolved asynchronously\r\n *    resolveAddress(Promise.resolve(addr))\r\n *    //_result:\r\n *\r\n *    // ENS names are resolved asynchronously\r\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\r\n *    //_result:\r\n *\r\n *    // Addressable objects are resolved asynchronously\r\n *    contract = new Contract(addr, [ ])\r\n *    resolveAddress(contract, provider)\r\n *    //_result:\r\n *\r\n *    // Unconfigured ENS names reject\r\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\r\n *    //_error:\r\n *\r\n *    // ENS names require a NameResolver object passed in\r\n *    // (notice the provider was omitted)\r\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\r\n *    //_error:\r\n */\r\nexport function resolveAddress(target: AddressLike, resolver?: null | NameResolver): string | Promise<string> {\r\n\r\n    if (typeof(target) === \"string\") {\r\n        if (target.match(/^0x[0-9a-f]{40}$/i)) { return getAddress(target); }\r\n\r\n        assert(resolver != null, \"ENS resolution requires a provider\",\r\n            \"UNSUPPORTED_OPERATION\", { operation: \"resolveName\" });\r\n\r\n        return checkAddress(target, resolver.resolveName(target));\r\n\r\n    } else if (isAddressable(target)) {\r\n        return checkAddress(target, target.getAddress());\r\n\r\n    } else if (target && typeof(target.then) === \"function\") {\r\n        return checkAddress(target, target);\r\n    }\r\n\r\n    assertArgument(false, \"unsupported addressable value\", \"target\", target);\r\n}\r\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,cAAc,QAAQ,mBAAmB;AAE1D,SAASC,UAAU,QAAQ,cAAc;AAKzC;;;;;;;;;;;;;;AAcA,OAAM,SAAUC,aAAaA,CAACC,KAAU;EACpC,OAAQA,KAAK,IAAI,OAAOA,KAAK,CAACF,UAAW,KAAK,UAAU;AAC5D;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,OAAM,SAAUG,SAASA,CAACD,KAAU;EAChC,IAAI;IACAF,UAAU,CAACE,KAAK,CAAC;IACjB,OAAO,IAAI;GACd,CAAC,OAAOE,KAAK,EAAE;EAChB,OAAO,KAAK;AAChB;AAEA,eAAeC,YAAYA,CAACC,MAAW,EAAEC,OAA+B;EACpE,MAAMC,MAAM,GAAG,MAAMD,OAAO;EAC5B,IAAIC,MAAM,IAAI,IAAI,IAAIA,MAAM,KAAK,4CAA4C,EAAE;IAC3EV,MAAM,CAAC,OAAOQ,MAAO,KAAK,QAAQ,EAAE,mBAAmB,EAAE,mBAAmB,EAAE;MAAEJ,KAAK,EAAEI;IAAM,CAAE,CAAC;IAChGP,cAAc,CAAC,KAAK,EAAE,+DAA+D,EAAE,QAAQ,EAAEO,MAAM,CAAC;;EAE5G,OAAON,UAAU,CAACQ,MAAM,CAAC;AAC7B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA,OAAM,SAAUC,cAAcA,CAACH,MAAmB,EAAEI,QAA8B;EAE9E,IAAI,OAAOJ,MAAO,KAAK,QAAQ,EAAE;IAC7B,IAAIA,MAAM,CAACK,KAAK,CAAC,mBAAmB,CAAC,EAAE;MAAE,OAAOX,UAAU,CAACM,MAAM,CAAC;;IAElER,MAAM,CAACY,QAAQ,IAAI,IAAI,EAAE,oCAAoC,EACzD,uBAAuB,EAAE;MAAEE,SAAS,EAAE;IAAa,CAAE,CAAC;IAE1D,OAAOP,YAAY,CAACC,MAAM,EAAEI,QAAQ,CAACG,WAAW,CAACP,MAAM,CAAC,CAAC;GAE5D,MAAM,IAAIL,aAAa,CAACK,MAAM,CAAC,EAAE;IAC9B,OAAOD,YAAY,CAACC,MAAM,EAAEA,MAAM,CAACN,UAAU,EAAE,CAAC;GAEnD,MAAM,IAAIM,MAAM,IAAI,OAAOA,MAAM,CAACQ,IAAK,KAAK,UAAU,EAAE;IACrD,OAAOT,YAAY,CAACC,MAAM,EAAEA,MAAM,CAAC;;EAGvCP,cAAc,CAAC,KAAK,EAAE,+BAA+B,EAAE,QAAQ,EAAEO,MAAM,CAAC;AAC5E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}