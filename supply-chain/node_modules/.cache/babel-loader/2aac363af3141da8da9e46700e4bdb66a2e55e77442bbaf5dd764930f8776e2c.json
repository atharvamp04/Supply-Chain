{"ast":null,"code":"/**\r\n *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value\r\n *  to be encoded as a compact string using a radix of 58 using only\r\n *  alpha-numeric characters. Confusingly similar characters are omitted\r\n *  (i.e. ``\"l0O\"``).\r\n *\r\n *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,\r\n *  since any zero-bytes on the left would get removed. To mitigate this\r\n *  issue most schemes that use Base58 choose specific high-order values\r\n *  to ensure non-zero prefixes.\r\n *\r\n *  @_subsection: api/utils:Base58 Encoding [about-base58]\r\n */\nimport { getBytes } from \"./data.js\";\nimport { assertArgument } from \"./errors.js\";\nimport { toBigInt } from \"./maths.js\";\nconst Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nlet Lookup = null;\nfunction getAlpha(letter) {\n  if (Lookup == null) {\n    Lookup = {};\n    for (let i = 0; i < Alphabet.length; i++) {\n      Lookup[Alphabet[i]] = BigInt(i);\n    }\n  }\n  const result = Lookup[letter];\n  assertArgument(result != null, `invalid base58 value`, \"letter\", letter);\n  return result;\n}\nconst BN_0 = BigInt(0);\nconst BN_58 = BigInt(58);\n/**\r\n *  Encode %%value%% as a Base58-encoded string.\r\n */\nexport function encodeBase58(_value) {\n  const bytes = getBytes(_value);\n  let value = toBigInt(bytes);\n  let result = \"\";\n  while (value) {\n    result = Alphabet[Number(value % BN_58)] + result;\n    value /= BN_58;\n  }\n  // Account for leading padding zeros\n  for (let i = 0; i < bytes.length; i++) {\n    if (bytes[i]) {\n      break;\n    }\n    result = Alphabet[0] + result;\n  }\n  return result;\n}\n/**\r\n *  Decode the Base58-encoded %%value%%.\r\n */\nexport function decodeBase58(value) {\n  let result = BN_0;\n  for (let i = 0; i < value.length; i++) {\n    result *= BN_58;\n    result += getAlpha(value[i]);\n  }\n  return result;\n}","map":{"version":3,"names":["getBytes","assertArgument","toBigInt","Alphabet","Lookup","getAlpha","letter","i","length","BigInt","result","BN_0","BN_58","encodeBase58","_value","bytes","value","Number","decodeBase58"],"sources":["C:\\Users\\patil\\OneDrive\\Desktop\\Hack4Good\\Supply-Chain\\supply-chain\\node_modules\\ethers\\src.ts\\utils\\base58.ts"],"sourcesContent":["/**\r\n *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value\r\n *  to be encoded as a compact string using a radix of 58 using only\r\n *  alpha-numeric characters. Confusingly similar characters are omitted\r\n *  (i.e. ``\"l0O\"``).\r\n *\r\n *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,\r\n *  since any zero-bytes on the left would get removed. To mitigate this\r\n *  issue most schemes that use Base58 choose specific high-order values\r\n *  to ensure non-zero prefixes.\r\n *\r\n *  @_subsection: api/utils:Base58 Encoding [about-base58]\r\n */\r\n\r\nimport { getBytes } from \"./data.js\";\r\nimport { assertArgument } from \"./errors.js\";\r\nimport { toBigInt } from \"./maths.js\";\r\n\r\nimport type { BytesLike } from \"./index.js\";\r\n\r\n\r\nconst Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\r\nlet Lookup: null | Record<string, bigint> = null;\r\n\r\nfunction getAlpha(letter: string): bigint {\r\n    if (Lookup == null) {\r\n        Lookup = { };\r\n        for (let i = 0; i < Alphabet.length; i++) {\r\n            Lookup[Alphabet[i]] = BigInt(i);\r\n        }\r\n    }\r\n    const result = Lookup[letter];\r\n    assertArgument(result != null, `invalid base58 value`, \"letter\", letter);\r\n    return result;\r\n}\r\n\r\n\r\nconst BN_0 = BigInt(0);\r\nconst BN_58 = BigInt(58);\r\n\r\n/**\r\n *  Encode %%value%% as a Base58-encoded string.\r\n */\r\nexport function encodeBase58(_value: BytesLike): string {\r\n    const bytes = getBytes(_value);\r\n\r\n    let value = toBigInt(bytes);\r\n    let result = \"\";\r\n    while (value) {\r\n        result = Alphabet[Number(value % BN_58)] + result;\r\n        value /= BN_58;\r\n    }\r\n\r\n    // Account for leading padding zeros\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        if (bytes[i]) { break; }\r\n        result = Alphabet[0] + result;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n *  Decode the Base58-encoded %%value%%.\r\n */\r\nexport function decodeBase58(value: string): bigint {\r\n    let result = BN_0;\r\n    for (let i = 0; i < value.length; i++) {\r\n        result *= BN_58;\r\n        result += getAlpha(value[i]);\r\n    }\r\n    return result;\r\n}\r\n"],"mappings":"AAAA;;;;;;;;;;;;;AAcA,SAASA,QAAQ,QAAQ,WAAW;AACpC,SAASC,cAAc,QAAQ,aAAa;AAC5C,SAASC,QAAQ,QAAQ,YAAY;AAKrC,MAAMC,QAAQ,GAAG,4DAA4D;AAC7E,IAAIC,MAAM,GAAkC,IAAI;AAEhD,SAASC,QAAQA,CAACC,MAAc;EAC5B,IAAIF,MAAM,IAAI,IAAI,EAAE;IAChBA,MAAM,GAAG,EAAG;IACZ,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,QAAQ,CAACK,MAAM,EAAED,CAAC,EAAE,EAAE;MACtCH,MAAM,CAACD,QAAQ,CAACI,CAAC,CAAC,CAAC,GAAGE,MAAM,CAACF,CAAC,CAAC;;;EAGvC,MAAMG,MAAM,GAAGN,MAAM,CAACE,MAAM,CAAC;EAC7BL,cAAc,CAACS,MAAM,IAAI,IAAI,EAAE,sBAAsB,EAAE,QAAQ,EAAEJ,MAAM,CAAC;EACxE,OAAOI,MAAM;AACjB;AAGA,MAAMC,IAAI,GAAGF,MAAM,CAAC,CAAC,CAAC;AACtB,MAAMG,KAAK,GAAGH,MAAM,CAAC,EAAE,CAAC;AAExB;;;AAGA,OAAM,SAAUI,YAAYA,CAACC,MAAiB;EAC1C,MAAMC,KAAK,GAAGf,QAAQ,CAACc,MAAM,CAAC;EAE9B,IAAIE,KAAK,GAAGd,QAAQ,CAACa,KAAK,CAAC;EAC3B,IAAIL,MAAM,GAAG,EAAE;EACf,OAAOM,KAAK,EAAE;IACVN,MAAM,GAAGP,QAAQ,CAACc,MAAM,CAACD,KAAK,GAAGJ,KAAK,CAAC,CAAC,GAAGF,MAAM;IACjDM,KAAK,IAAIJ,KAAK;;EAGlB;EACA,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,KAAK,CAACP,MAAM,EAAED,CAAC,EAAE,EAAE;IACnC,IAAIQ,KAAK,CAACR,CAAC,CAAC,EAAE;MAAE;;IAChBG,MAAM,GAAGP,QAAQ,CAAC,CAAC,CAAC,GAAGO,MAAM;;EAGjC,OAAOA,MAAM;AACjB;AAEA;;;AAGA,OAAM,SAAUQ,YAAYA,CAACF,KAAa;EACtC,IAAIN,MAAM,GAAGC,IAAI;EACjB,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGS,KAAK,CAACR,MAAM,EAAED,CAAC,EAAE,EAAE;IACnCG,MAAM,IAAIE,KAAK;IACfF,MAAM,IAAIL,QAAQ,CAACW,KAAK,CAACT,CAAC,CAAC,CAAC;;EAEhC,OAAOG,MAAM;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}