{"ast":null,"code":"/**\r\n *  A **Password-Based Key-Derivation Function** is designed to create\r\n *  a sequence of bytes suitible as a **key** from a human-rememberable\r\n *  password.\r\n *\r\n *  @_subsection: api/crypto:Passwords  [about-pbkdf]\r\n */\nimport { pbkdf2Sync } from \"./crypto.js\";\nimport { getBytes, hexlify } from \"../utils/index.js\";\nlet locked = false;\nconst _pbkdf2 = function (password, salt, iterations, keylen, algo) {\n  return pbkdf2Sync(password, salt, iterations, keylen, algo);\n};\nlet __pbkdf2 = _pbkdf2;\n/**\r\n *  Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using\r\n *  the %%salt%% and using %%iterations%% of %%algo%%.\r\n *\r\n *  This PBKDF is outdated and should not be used in new projects, but is\r\n *  required to decrypt older files.\r\n *\r\n *  @example:\r\n *    // The password must be converted to bytes, and it is generally\r\n *    // best practices to ensure the string has been normalized. Many\r\n *    // formats explicitly indicate the normalization form to use.\r\n *    password = \"hello\"\r\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\r\n *\r\n *    salt = id(\"some-salt\")\r\n *\r\n *    // Compute the PBKDF2\r\n *    pbkdf2(passwordBytes, salt, 1024, 16, \"sha256\")\r\n *    //_result:\r\n */\nexport function pbkdf2(_password, _salt, iterations, keylen, algo) {\n  const password = getBytes(_password, \"password\");\n  const salt = getBytes(_salt, \"salt\");\n  return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));\n}\npbkdf2._ = _pbkdf2;\npbkdf2.lock = function () {\n  locked = true;\n};\npbkdf2.register = function (func) {\n  if (locked) {\n    throw new Error(\"pbkdf2 is locked\");\n  }\n  __pbkdf2 = func;\n};\nObject.freeze(pbkdf2);","map":{"version":3,"names":["pbkdf2Sync","getBytes","hexlify","locked","_pbkdf2","password","salt","iterations","keylen","algo","__pbkdf2","pbkdf2","_password","_salt","_","lock","register","func","Error","Object","freeze"],"sources":["C:\\Users\\patil\\OneDrive\\Desktop\\Hack4Good\\Supply-Chain\\supply-chain\\node_modules\\ethers\\src.ts\\crypto\\pbkdf2.ts"],"sourcesContent":["/**\r\n *  A **Password-Based Key-Derivation Function** is designed to create\r\n *  a sequence of bytes suitible as a **key** from a human-rememberable\r\n *  password.\r\n *\r\n *  @_subsection: api/crypto:Passwords  [about-pbkdf]\r\n */\r\n\r\nimport { pbkdf2Sync } from \"./crypto.js\";\r\n\r\nimport { getBytes, hexlify } from \"../utils/index.js\";\r\n\r\nimport type { BytesLike } from \"../utils/index.js\";\r\n\r\n\r\nlet locked = false;\r\n\r\nconst _pbkdf2 = function(password: Uint8Array, salt: Uint8Array, iterations: number, keylen: number, algo: \"sha256\" | \"sha512\"): BytesLike {\r\n    return pbkdf2Sync(password, salt, iterations, keylen, algo);\r\n}\r\n\r\nlet __pbkdf2 = _pbkdf2;\r\n\r\n/**\r\n *  Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using\r\n *  the %%salt%% and using %%iterations%% of %%algo%%.\r\n *\r\n *  This PBKDF is outdated and should not be used in new projects, but is\r\n *  required to decrypt older files.\r\n *\r\n *  @example:\r\n *    // The password must be converted to bytes, and it is generally\r\n *    // best practices to ensure the string has been normalized. Many\r\n *    // formats explicitly indicate the normalization form to use.\r\n *    password = \"hello\"\r\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\r\n *\r\n *    salt = id(\"some-salt\")\r\n *\r\n *    // Compute the PBKDF2\r\n *    pbkdf2(passwordBytes, salt, 1024, 16, \"sha256\")\r\n *    //_result:\r\n */\r\nexport function pbkdf2(_password: BytesLike, _salt: BytesLike, iterations: number, keylen: number, algo: \"sha256\" | \"sha512\"): string {\r\n    const password = getBytes(_password, \"password\");\r\n    const salt = getBytes(_salt, \"salt\");\r\n    return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));\r\n}\r\npbkdf2._ = _pbkdf2;\r\npbkdf2.lock = function(): void { locked = true; }\r\npbkdf2.register = function(func: (password: Uint8Array, salt: Uint8Array, iterations: number, keylen: number, algo: \"sha256\" | \"sha512\") => BytesLike) {\r\n    if (locked) { throw new Error(\"pbkdf2 is locked\"); }\r\n    __pbkdf2 = func;\r\n}\r\nObject.freeze(pbkdf2);\r\n"],"mappings":"AAAA;;;;;;;AAQA,SAASA,UAAU,QAAQ,aAAa;AAExC,SAASC,QAAQ,EAAEC,OAAO,QAAQ,mBAAmB;AAKrD,IAAIC,MAAM,GAAG,KAAK;AAElB,MAAMC,OAAO,GAAG,SAAAA,CAASC,QAAoB,EAAEC,IAAgB,EAAEC,UAAkB,EAAEC,MAAc,EAAEC,IAAyB;EAC1H,OAAOT,UAAU,CAACK,QAAQ,EAAEC,IAAI,EAAEC,UAAU,EAAEC,MAAM,EAAEC,IAAI,CAAC;AAC/D,CAAC;AAED,IAAIC,QAAQ,GAAGN,OAAO;AAEtB;;;;;;;;;;;;;;;;;;;;AAoBA,OAAM,SAAUO,MAAMA,CAACC,SAAoB,EAAEC,KAAgB,EAAEN,UAAkB,EAAEC,MAAc,EAAEC,IAAyB;EACxH,MAAMJ,QAAQ,GAAGJ,QAAQ,CAACW,SAAS,EAAE,UAAU,CAAC;EAChD,MAAMN,IAAI,GAAGL,QAAQ,CAACY,KAAK,EAAE,MAAM,CAAC;EACpC,OAAOX,OAAO,CAACQ,QAAQ,CAACL,QAAQ,EAAEC,IAAI,EAAEC,UAAU,EAAEC,MAAM,EAAEC,IAAI,CAAC,CAAC;AACtE;AACAE,MAAM,CAACG,CAAC,GAAGV,OAAO;AAClBO,MAAM,CAACI,IAAI,GAAG;EAAmBZ,MAAM,GAAG,IAAI;AAAE,CAAC;AACjDQ,MAAM,CAACK,QAAQ,GAAG,UAASC,IAA0H;EACjJ,IAAId,MAAM,EAAE;IAAE,MAAM,IAAIe,KAAK,CAAC,kBAAkB,CAAC;;EACjDR,QAAQ,GAAGO,IAAI;AACnB,CAAC;AACDE,MAAM,CAACC,MAAM,CAACT,MAAM,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}