{"ast":null,"code":"/**\r\n *  Events allow for applications to use the observer pattern, which\r\n *  allows subscribing and publishing events, outside the normal\r\n *  execution paths.\r\n *\r\n *  @_section api/utils/events:Events  [about-events]\r\n */\nimport { defineProperties } from \"./properties.js\";\n/**\r\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\r\n *  callback always ahas one additional argument passed, which is\r\n *  an **EventPayload**.\r\n */\nexport class EventPayload {\n  /**\r\n   *  The event filter.\r\n   */\n  filter;\n  /**\r\n   *  The **EventEmitterable**.\r\n   */\n  emitter;\n  #listener;\n  /**\r\n   *  Create a new **EventPayload** for %%emitter%% with\r\n   *  the %%listener%% and for %%filter%%.\r\n   */\n  constructor(emitter, listener, filter) {\n    this.#listener = listener;\n    defineProperties(this, {\n      emitter,\n      filter\n    });\n  }\n  /**\r\n   *  Unregister the triggered listener for future events.\r\n   */\n  async removeListener() {\n    if (this.#listener == null) {\n      return;\n    }\n    await this.emitter.off(this.filter, this.#listener);\n  }\n}","map":{"version":3,"names":["defineProperties","EventPayload","filter","emitter","listener","constructor","removeListener","off"],"sources":["C:\\Users\\patil\\OneDrive\\Desktop\\Hack4Good\\Supply-Chain\\supply-chain\\node_modules\\ethers\\src.ts\\utils\\events.ts"],"sourcesContent":["/**\r\n *  Events allow for applications to use the observer pattern, which\r\n *  allows subscribing and publishing events, outside the normal\r\n *  execution paths.\r\n *\r\n *  @_section api/utils/events:Events  [about-events]\r\n */\r\nimport { defineProperties } from \"./properties.js\";\r\n\r\n/**\r\n *  A callback function called when a an event is triggered.\r\n */\r\nexport type Listener = (...args: Array<any>) => void;\r\n\r\n/**\r\n *  An **EventEmitterable** behaves similar to an EventEmitter\r\n *  except provides async access to its methods.\r\n *\r\n *  An EventEmitter implements the observer pattern.\r\n */\r\nexport interface EventEmitterable<T> {\r\n    /**\r\n     *  Registers a %%listener%% that is called whenever the\r\n     *  %%event%% occurs until unregistered.\r\n     */\r\n    on(event: T, listener: Listener): Promise<this>;\r\n\r\n    /**\r\n     *  Registers a %%listener%% that is called the next time\r\n     *  %%event%% occurs.\r\n     */\r\n    once(event: T, listener: Listener): Promise<this>;\r\n\r\n    /**\r\n     *  Triggers each listener for %%event%% with the %%args%%.\r\n     */\r\n    emit(event: T, ...args: Array<any>): Promise<boolean>;\r\n\r\n    /**\r\n     *  Resolves to the number of listeners for %%event%%.\r\n     */\r\n    listenerCount(event?: T): Promise<number>;\r\n\r\n    /**\r\n     *  Resolves to the listeners for %%event%%.\r\n     */\r\n    listeners(event?: T): Promise<Array<Listener>>;\r\n\r\n    /**\r\n     *  Unregister the %%listener%% for %%event%%. If %%listener%%\r\n     *  is unspecified, all listeners are unregistered.\r\n     */\r\n    off(event: T, listener?: Listener): Promise<this>;\r\n\r\n    /**\r\n     *  Unregister all listeners for %%event%%.\r\n     */\r\n    removeAllListeners(event?: T): Promise<this>;\r\n\r\n    /**\r\n     *  Alias for [[on]].\r\n     */\r\n    addListener(event: T, listener: Listener): Promise<this>;\r\n\r\n    /**\r\n     *  Alias for [[off]].\r\n     */\r\n    removeListener(event: T, listener: Listener): Promise<this>;\r\n}\r\n\r\n/**\r\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\r\n *  callback always ahas one additional argument passed, which is\r\n *  an **EventPayload**.\r\n */\r\nexport class EventPayload<T> {\r\n    /**\r\n     *  The event filter.\r\n     */\r\n    readonly filter!: T;\r\n\r\n    /**\r\n     *  The **EventEmitterable**.\r\n     */\r\n    readonly emitter!: EventEmitterable<T>;\r\n\r\n    readonly #listener: null | Listener;\r\n\r\n    /**\r\n     *  Create a new **EventPayload** for %%emitter%% with\r\n     *  the %%listener%% and for %%filter%%.\r\n     */\r\n    constructor(emitter: EventEmitterable<T>, listener: null | Listener, filter: T) {\r\n        this.#listener = listener;\r\n        defineProperties<EventPayload<any>>(this, { emitter, filter });\r\n    }\r\n\r\n    /**\r\n     *  Unregister the triggered listener for future events.\r\n     */\r\n    async removeListener(): Promise<void> {\r\n        if (this.#listener == null) { return; }\r\n        await this.emitter.off(this.filter, this.#listener);\r\n    }\r\n}\r\n"],"mappings":"AAAA;;;;;;;AAOA,SAASA,gBAAgB,QAAQ,iBAAiB;AA+DlD;;;;;AAKA,OAAM,MAAOC,YAAY;EACrB;;;EAGSC,MAAM;EAEf;;;EAGSC,OAAO;EAEP,CAAAC,QAAS;EAElB;;;;EAIAC,YAAYF,OAA4B,EAAEC,QAAyB,EAAEF,MAAS;IAC1E,IAAI,CAAC,CAAAE,QAAS,GAAGA,QAAQ;IACzBJ,gBAAgB,CAAoB,IAAI,EAAE;MAAEG,OAAO;MAAED;IAAM,CAAE,CAAC;EAClE;EAEA;;;EAGA,MAAMI,cAAcA,CAAA;IAChB,IAAI,IAAI,CAAC,CAAAF,QAAS,IAAI,IAAI,EAAE;MAAE;;IAC9B,MAAM,IAAI,CAACD,OAAO,CAACI,GAAG,CAAC,IAAI,CAACL,MAAM,EAAE,IAAI,CAAC,CAAAE,QAAS,CAAC;EACvD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}