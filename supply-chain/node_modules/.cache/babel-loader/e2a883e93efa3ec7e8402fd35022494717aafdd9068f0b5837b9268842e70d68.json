{"ast":null,"code":"import { getAddress } from \"../address/index.js\";\nimport { keccak256 as _keccak256, sha256 as _sha256 } from \"../crypto/index.js\";\nimport { concat, dataLength, getBytes, hexlify, toBeArray, toTwos, toUtf8Bytes, zeroPadBytes, zeroPadValue, assertArgument } from \"../utils/index.js\";\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\nfunction _pack(type, value, isArray) {\n  switch (type) {\n    case \"address\":\n      if (isArray) {\n        return getBytes(zeroPadValue(value, 32));\n      }\n      return getBytes(getAddress(value));\n    case \"string\":\n      return toUtf8Bytes(value);\n    case \"bytes\":\n      return getBytes(value);\n    case \"bool\":\n      value = !!value ? \"0x01\" : \"0x00\";\n      if (isArray) {\n        return getBytes(zeroPadValue(value, 32));\n      }\n      return getBytes(value);\n  }\n  let match = type.match(regexNumber);\n  if (match) {\n    let signed = match[1] === \"int\";\n    let size = parseInt(match[2] || \"256\");\n    assertArgument((!match[2] || match[2] === String(size)) && size % 8 === 0 && size !== 0 && size <= 256, \"invalid number type\", \"type\", type);\n    if (isArray) {\n      size = 256;\n    }\n    if (signed) {\n      value = toTwos(value, size);\n    }\n    return getBytes(zeroPadValue(toBeArray(value), size / 8));\n  }\n  match = type.match(regexBytes);\n  if (match) {\n    const size = parseInt(match[1]);\n    assertArgument(String(size) === match[1] && size !== 0 && size <= 32, \"invalid bytes type\", \"type\", type);\n    assertArgument(dataLength(value) === size, `invalid value for ${type}`, \"value\", value);\n    if (isArray) {\n      return getBytes(zeroPadBytes(value, 32));\n    }\n    return value;\n  }\n  match = type.match(regexArray);\n  if (match && Array.isArray(value)) {\n    const baseType = match[1];\n    const count = parseInt(match[2] || String(value.length));\n    assertArgument(count === value.length, `invalid array length for ${type}`, \"value\", value);\n    const result = [];\n    value.forEach(function (value) {\n      result.push(_pack(baseType, value, true));\n    });\n    return getBytes(concat(result));\n  }\n  assertArgument(false, \"invalid type\", \"type\", type);\n}\n// @TODO: Array Enum\n/**\r\n *   Computes the [[link-solc-packed]] representation of %%values%%\r\n *   respectively to their %%types%%.\r\n *\r\n *   @example:\r\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\r\n *       solidityPacked([ \"address\", \"uint\" ], [ addr, 45 ]);\r\n *       //_result:\r\n */\nexport function solidityPacked(types, values) {\n  assertArgument(types.length === values.length, \"wrong number of values; expected ${ types.length }\", \"values\", values);\n  const tight = [];\n  types.forEach(function (type, index) {\n    tight.push(_pack(type, values[index]));\n  });\n  return hexlify(concat(tight));\n}\n/**\r\n *   Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%\r\n *   respectively to their %%types%%.\r\n *\r\n *   @example:\r\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\r\n *       solidityPackedKeccak256([ \"address\", \"uint\" ], [ addr, 45 ]);\r\n *       //_result:\r\n */\nexport function solidityPackedKeccak256(types, values) {\n  return _keccak256(solidityPacked(types, values));\n}\n/**\r\n *   Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%\r\n *   respectively to their %%types%%.\r\n *\r\n *   @example:\r\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\r\n *       solidityPackedSha256([ \"address\", \"uint\" ], [ addr, 45 ]);\r\n *       //_result:\r\n */\nexport function solidityPackedSha256(types, values) {\n  return _sha256(solidityPacked(types, values));\n}","map":{"version":3,"names":["getAddress","keccak256","_keccak256","sha256","_sha256","concat","dataLength","getBytes","hexlify","toBeArray","toTwos","toUtf8Bytes","zeroPadBytes","zeroPadValue","assertArgument","regexBytes","RegExp","regexNumber","regexArray","_pack","type","value","isArray","match","signed","size","parseInt","String","Array","baseType","count","length","result","forEach","push","solidityPacked","types","values","tight","index","solidityPackedKeccak256","solidityPackedSha256"],"sources":["C:\\Users\\patil\\OneDrive\\Desktop\\Hack4Good\\Supply-Chain\\supply-chain\\node_modules\\ethers\\src.ts\\hash\\solidity.ts"],"sourcesContent":["import { getAddress } from \"../address/index.js\";\r\nimport {\r\n    keccak256 as _keccak256, sha256 as _sha256\r\n} from \"../crypto/index.js\";\r\nimport {\r\n    concat, dataLength, getBytes, hexlify, toBeArray, toTwos, toUtf8Bytes, zeroPadBytes, zeroPadValue,\r\n    assertArgument\r\n} from \"../utils/index.js\";\r\n\r\n\r\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\r\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\r\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\r\n\r\n\r\nfunction _pack(type: string, value: any, isArray?: boolean): Uint8Array {\r\n    switch(type) {\r\n        case \"address\":\r\n            if (isArray) { return getBytes(zeroPadValue(value, 32)); }\r\n            return getBytes(getAddress(value));\r\n        case \"string\":\r\n            return toUtf8Bytes(value);\r\n        case \"bytes\":\r\n            return getBytes(value);\r\n        case \"bool\":\r\n            value = (!!value ? \"0x01\": \"0x00\");\r\n            if (isArray) { return getBytes(zeroPadValue(value, 32)); }\r\n            return getBytes(value);\r\n    }\r\n\r\n    let match =  type.match(regexNumber);\r\n    if (match) {\r\n        let signed = (match[1] === \"int\");\r\n        let size = parseInt(match[2] || \"256\")\r\n\r\n        assertArgument((!match[2] || match[2] === String(size)) && (size % 8 === 0) && size !== 0 && size <= 256, \"invalid number type\", \"type\", type);\r\n\r\n        if (isArray) { size = 256; }\r\n\r\n        if (signed) { value = toTwos(value, size); }\r\n\r\n        return getBytes(zeroPadValue(toBeArray(value), size / 8));\r\n    }\r\n\r\n    match = type.match(regexBytes);\r\n    if (match) {\r\n        const size = parseInt(match[1]);\r\n\r\n        assertArgument(String(size) === match[1] && size !== 0 && size <= 32, \"invalid bytes type\", \"type\", type);\r\n        assertArgument(dataLength(value) === size, `invalid value for ${ type }`, \"value\", value);\r\n\r\n        if (isArray) { return getBytes(zeroPadBytes(value, 32)); }\r\n        return value;\r\n    }\r\n\r\n    match = type.match(regexArray);\r\n    if (match && Array.isArray(value)) {\r\n        const baseType = match[1];\r\n        const count = parseInt(match[2] || String(value.length));\r\n        assertArgument(count === value.length, `invalid array length for ${ type }`, \"value\", value);\r\n\r\n        const result: Array<Uint8Array> = [];\r\n        value.forEach(function(value) {\r\n            result.push(_pack(baseType, value, true));\r\n        });\r\n        return getBytes(concat(result));\r\n    }\r\n\r\n    assertArgument(false, \"invalid type\", \"type\", type)\r\n}\r\n\r\n// @TODO: Array Enum\r\n\r\n/**\r\n *   Computes the [[link-solc-packed]] representation of %%values%%\r\n *   respectively to their %%types%%.\r\n *\r\n *   @example:\r\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\r\n *       solidityPacked([ \"address\", \"uint\" ], [ addr, 45 ]);\r\n *       //_result:\r\n */\r\nexport function solidityPacked(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\r\n    assertArgument(types.length === values.length, \"wrong number of values; expected ${ types.length }\", \"values\", values);\r\n\r\n    const tight: Array<Uint8Array> = [];\r\n    types.forEach(function(type, index) {\r\n        tight.push(_pack(type, values[index]));\r\n    });\r\n    return hexlify(concat(tight));\r\n}\r\n\r\n/**\r\n *   Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%\r\n *   respectively to their %%types%%.\r\n *\r\n *   @example:\r\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\r\n *       solidityPackedKeccak256([ \"address\", \"uint\" ], [ addr, 45 ]);\r\n *       //_result:\r\n */\r\nexport function solidityPackedKeccak256(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\r\n    return _keccak256(solidityPacked(types, values));\r\n}\r\n\r\n/**\r\n *   Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%\r\n *   respectively to their %%types%%.\r\n *\r\n *   @example:\r\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\r\n *       solidityPackedSha256([ \"address\", \"uint\" ], [ addr, 45 ]);\r\n *       //_result:\r\n */\r\nexport function solidityPackedSha256(types: ReadonlyArray<string>, values: ReadonlyArray<any>): string {\r\n    return _sha256(solidityPacked(types, values));\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}